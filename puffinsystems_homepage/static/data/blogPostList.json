[
    {
        "title": "Demo Markdown Notebook",
        "body": "![demo markdown notebook screenshot](/images/blog/20230712_markdown_notebook.png)\n\n## Overview\n\nThis basic note taking app was my first project after completing the [Mozilla Svelte Tutorial](https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Svelte_getting_started) and was used to explore how Svelte connects to other libraries. Over the course of about 2 weeks, I successfully mashed a bunch of things together. This is some of my experiences.\n\n### Update 2023-12-18\n\nThis blog post was updated to be more sensible. I also deployed everything on AWS using SST instead of syncing to an S3 bucket like a neanderthal.\n\n## Svelte\n\nSvelte was extremely easy to pick up. Components can be dynamic component and styled all from a single file. Considering my experience so far at this point was with Django and HTMX, this probably isn't surprising.\n\n## Typescript\n\nI can understand why Typescript would be a requirement for large and complex projects. When everything has a clear type, it is easier to understand how you should use different functions and objects. However, there is an annoying learning curve. I found many of the type errors provided by VSCode confusing.\n\n### Tailwindcss\n\nI took me a while to understand Tailwind, probably because I didn't understand CSS.  I was also comparing it to Bootstrap which provided complete components with classes, not just styles. Now I think Tailwind is invaluable due to the customization and flexibility. I still don't understand CSS.\n\nThe HTML class names are unwieldy, but using classes allowed for better uniformity between components without  global styles.\n\nTailwind also has a great plugin for typography.\n\n### Ace Editor\n\nAce is a web text/code editor with support for writing markdown. Although I could have used the an Svelte Ace component package, I decided to implement the component myself for practice. Svelte doesn't have a large package ecosystem, so it is important learn how to create custom components for existing JS package.\n\nThe documentation for Ace was frustratingly sparse. I should have just used a better  markdown editor.",
        "slug_url": "2023-07-12_demo-markdown-notebook",
        "date_created": "2023-07-12",
        "date_updated": "2023-12-18"
    },
    {
        "title": "Confluence To Obsidian",
        "body": "![Confluence to Obsidian logos](/images/blog/20230801_confluence_to_obsidian.png)\n\n# Overview\n\nThis describes how I migrated my notes from Confluence to Obsidian. More specifically, the Confluence HTML to markdown scripts I created in https://github.com/magicalpuffin/Confluence-to-Obsidian.\n\nThere wasn't a lot of information or solutions online for exporting a confluence workspace to markdown. When I was migrating all of my Confluence notes to Obsidian, I decided to give it a try.\n\nThis is not a complete solution. I just got far enough that I was fine with the results.\n\nI was only really prioritizing two things during the conversion:\n\n1. Preserve any text written and convert it to markdown\n2. Avoid excessive HTML. Try to keep everything plain markdown\n\nAs a result, the following weren't converted to markdown:\n\n1. Folder structure\n2. Images\n3. Attachments\n4. Internal links between notebooks\n\nThe end result was just a massive folder with each page as a markdown file which I could copy into and search in Obsidian.\n\nAttachments can just be copied over from the confluence export to the new markdown folder. It should be possible to modify the scripts that I used to get the export you want. The rest of this post will explain how it works.\n\n# How it works\n\nFirst export a Confluence workspace to HTML. The HTML is then converted to markdown using a Pandoc in a PowerShell script. Due to the the Confluence HTML format, not everything can get easily converted, so Lua filter is used to define how Pandoc should convert different HTML elements.\n\n## PowerShell script\n\n```\n# ConvetHTMLToMarkdown.ps1\n\n# Set the path to the folder containing the HTML files\n$sourceFolder = \"./confluence_workspace\"\n\n# Set the path to the folder containing generated Markdown files\n$destinationFolder = \"./markdown\"\n\n# Set the path to the lua filter script\n$luaFilterPath = \"filter_html.lua\"\n\n# Get all HTML files in the folder\n$htmlFiles = Get-ChildItem -Path $sourceFolder -Filter \"*.html\" -File\n\n# Loop through each HTML file and convert to Markdown using Pandoc\n# foreach ($htmlFile in $htmlFiles[0..10]) {\nforeach ($htmlFile in $htmlFiles) {\n    $htmlFilePath = $htmlFile.FullName\n    $markdownFileName = Join-Path -Path $destinationFolder -ChildPath ([System.IO.Path]::ChangeExtension($htmlFile.Name, \"md\"))\n\n    $command = \"pandoc '$htmlFilePath' -f html -t gfm -L '$luaFilterPath' -s -o '$markdownFileName'\"\n    Invoke-Expression $command\n}\n```\n\n- There wasn't any particular reason why PowerShell was used. This could be created in bash.\n- The script sets all of the parameters and file paths\n- It loops through all of the HTML files and runs the Pandoc command to convert the file to markdown\n- I would recommend converting a few files first to check the results before looping through the entire exported workspace.\n\n## Pandoc\n\n```\npandoc '$htmlFilePath' -f html -t gfm -L '$luaFilterPath' -s -o '$markdownFileName'\n```\n\n- Install Pandoc. https://pandoc.org/installing.html\n- The command converts from HTML to GitHub Flavored Markdown using the Lua filter.\n- GitHub Flavored Markdown converted the most from Confluence HTML. It was the only format I found which could convert the Confluence HTML tables.\n\n## Lua Filter\n\n```\n-- filter_html.lua\n\nfunction Span(el)\n  return el.content\nend\n\nfunction Div(el)\n  -- Removes footer\n  if el.identifier == \"footer\" then\n    return {}\n  end\n  -- Removes breadcrumb header\n  if el.identifier == \"breadcrumb-section\" then\n    return {}\n  end\n  -- Removes attachments plugin\n  if el.classes:includes(\"plugin_attachments_container\") then\n    return {}\n  end\n  return el.content\nend\n\nfunction Para(el)\n  if el.content then\n    for _, item in ipairs(el.content) do\n      -- Out of order execution, converted links should not be stringified\n      if item.t == \"RawInline\" then\n        return el\n      end\n    end\n    return pandoc.utils.stringify(el.content)\n  end\nend\n\nfunction Image(el)\n  return {}\nend\n\nfunction Link(el)\n  -- if el.classes:find(\"download-all-link\", 0) then\n  --   return {}\n  -- end\n  if el.classes:includes(\"external-link\") then\n    link_text = pandoc.utils.stringify(el.content)\n    link_url = el.target\n    markdown_link = string.format(\"[%s](%s)\", link_text, link_url)\n\n    return {pandoc.RawInline(\"gfm\", markdown_link)}\n  end\nend\n\n-- function Table(el)\n--   if el.classes:find(\"attachments\", 0) then\n--     return {}\n--   end\n-- end\n```\n\n- I don't know Lua and I didn't really understand the Pandoc documentation. https://pandoc.org/lua-filters.html\n- Only includes the contents within Span elements\n- Removes the extra HTML Divs used by Confluence in the page layout\n- Paragraphs are difficult to format because Confluence uses paragraph elements within lists. The filter tries to convert them to strings in order for the list to be formatted without extra indents.\n  - Due to out of order execution, the link conversion filter executes first. To avoid breaking the link format, `RawInline` gets ignored\n  - This is messy and I couldn't figure out a better way to do this. This results in inconsistent spacing for lists whenever there is a link.\n- Images were removed because I didn't want to figure out how to fix them.\n- Links are converted from HTML into the markdown format.",
        "slug_url": "2023-08-01_confluence-to-obsidian",
        "date_created": "2023-08-01",
        "date_updated": "2023-11-04"
    },
    {
        "title": "Demo Manufacturing Kanban",
        "body": "![demo mfg kanban screenshot](/images/blog/20230715_mfg_kanban.png)\n\n## Overview\n\nThis post will describe the original Django version of this project. I plan on remaking this project using Svelte and Django Rest Framework.\n\nThe very first draft of this project was created in a few hours as quickly as possible. The idea was to create a custom kanban system similar to what is available with Jira and Smartsheets.\n\nFrontend and backend was created using Django and Htmx. This was deployed to AWS Lambda using Zappa. The database is an sqlite database on AWS S3.\n\n## Objective\n\nThis project was created to test out how quickly Django could be used to create a basic web app.\n\nLooking back at my commits, this project was started on 2023-04-19 and completed on 2023-04-22. This project was rushed.\n\n## Key Libraries and Packages\n\n### Django\n\nDjango is an extremely fast batteries included python web framework. If you are building a CRUD app and want a ORM, Django is probably the fastest option. However, if you plan building anything complicated for the frontend Django will become unmaintainable very quickly.\n\nMost other web frameworks (ex. Svelte) use JS and a component based system for the frontend. This allows them to be interactive and flexible. For Django and its Jinja templates to be comparable, janky JS or Htmx is required.\n\nHowever, everything on the backend is handled fairly well by Django. Perhaps that's why people care more about Django Rest Framework than Django.\n\n### Bootstrap\n\nBootstrap is a CSS component library. Instead of having the user define all of the details and configure their own components such as with Tailwind, Bootstrap, just defines what all the components look like.\n\nThis makes it fast but inflexible. Everything always looks like a Bootstrap component. This is still probably the fastest way to get good looking CSS on a Django app, which was why I used it here.\n\n### Htmx\n\nHtmx basically lets you do JS things such as HTTP requests in html. This is great for Django because you are able to request different endpoints and swap out sections of html using `hx-swap` and `hx-target`.\n\nThis allowed me to make it feel like this was a single page app without a lot of JS. Although, every requrest still required the server to do the rendering.\n\n### Sortable JS\n\nSortable was the JS framework used to allow drag, drop and reordering of cards. I am actually kind of surprised this worked as well as it did.\n\nDue to how Django works, this required some weird JS on the base template. After placing each card down, it Htmx is used to save the order of items to the database.\n\n### Zappa\n\nZappa makes it possible to deploying Django apps serverless on AWS. It does still seem a bit janky with most tutorials being incomplete. The best tutorial I found was:\n\nhttps://romandc.com/zappa-django-guide/\n\nZappa also does not fit in well within a stack. Other resources (ex. RDS and CloudFront) will need to be configured separately. Ideally you would be able to deploy the Django Lambda using AWS CDK.\n\n### Django S3 Sqlite\n\nDjango automatically uses an sqlite database, however, when deployed on AWS Lambda, sqlite can't be used due to the dependency missing in the Lambda environment.\n\nAn interesting work around is the package `django-s3-sqlite`. This allows you to access an sqlite databae on S3. For a database which will rarely be used, this is a much better alternative than spinning up an RDS instance. I guess this counts as a serverless database.",
        "slug_url": "2023-07-15_demo-manufacturing-kanban",
        "date_created": "2023-07-15",
        "date_updated": "2023-11-04"
    }
]